<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS上传到App Store一直出错]]></title>
    <url>%2F2018%2F02%2F22%2FiOS%E4%B8%8A%E4%BC%A0%E5%8C%85%E5%88%B0App%20Store%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[上周使用app Loader上传到App Store的包一直显示上传到App Store出错，如下图所示，没有任何其他的提示，在别人的Mac电脑上能成功上传，后来以为是Xcode的缘故，于是把Xcode 卸载之后重新安装还是出错，后来在stackoverflow找到了解决办法,具体操作如下 出错的截图 解决办法打开终端按步骤来 1. cd ~ 2. mv .itmstransporter/ .old_itmstransporter/ 3. &quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/bin/iTMSTransporte]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础动画总结]]></title>
    <url>%2F2018%2F02%2F22%2FiOS%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介 iOS动画主要是指Core Animation框架，官方使用地址为：Core Animation Guide。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 Core Animation常用字段 常用属性 duration : 动画的持续时间 beginTime : 动画的开始时间 repeatCount : 动画的重复次数 autoreverses : 执行的动画按照原动画返回执行 timingFunction : 控制动画的显示节奏系统提供五种值选择，分别是：- kCAMediaTimingFunctionLinear 线性动画 - kCAMediaTimingFunctionEaseIn 先慢后快 - kCAMediaTimingFunctionEaseOut 先快后慢 - kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢 - kCAMediaTimingFunctionDefault 默认，也属于中间比较快 path：关键帧动画中的执行路径 type ： 过渡动画的动画类型，系统提供了四种过渡动画。 iOS动画的调用方式 第一种：UIView代码块调用 [UIView animateWithDuration:1.0f animations:^{ _demoView.frame = CGRectMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-50, 50, 50); } completion:^(BOOL finished) { _demoView.frame = CGRectMake(SCREEN_WIDTH/2-25, SCREEN_HEIGHT/2-50, 50, 50); }]; 第二种：UIView [begin commit]的模式 [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:1.0f]; _demoView.frame = CGRectMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-50, 50, 50); [UIView commitAnimations]; 使用Core Animation中的类 CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)]; anima.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-75)]; anima.duration = 1.0f; [_demoView.layer addAnimation:anima forKey:@&quot;positionAnimation&quot;]; iOS动画的使用 使用CAShapeLayer画一个不规矩的图形 要想实现这个效果，先建立一个CAShapeLayer的类别，在类别方法里面实现4-1的方法，然后在viewDidLoad中实现下面4-2的代码 CAShapeLayer类别里面实现方法 + (instancetype)createMaskLayerWithView:(UIView *)view{ CGFloat viewWidth = CGRectGetWidth(view.frame); CGFloat viewHeight = CGRectGetHeight(view.frame); CGFloat rightSpace = 10.0f; CGFloat topSpace = 15; CGPoint point1 = CGPointMake(0, 0); CGPoint point2 = CGPointMake(viewWidth-rightSpace, 0); CGPoint point3 = CGPointMake(viewWidth-rightSpace, topSpace); CGPoint point4 = CGPointMake(viewWidth, topSpace); CGPoint point5 = CGPointMake(viewWidth-rightSpace, topSpace+10.); CGPoint point6 = CGPointMake(viewWidth-rightSpace, viewHeight); CGPoint point7 = CGPointMake(0, viewHeight); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point1]; [path addLineToPoint:point2]; [path addLineToPoint:point3]; [path addLineToPoint:point4]; [path addLineToPoint:point5]; [path addLineToPoint:point6]; [path addLineToPoint:point7]; [path closePath]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.fillColor = [UIColor greenColor].CGColor; layer.path = path.CGPath; return layer; } - 调用方法 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 80, 100)]; view.backgroundColor = [UIColor orangeColor]; [self.view addSubview:view]; CAShapeLayer *layer = [CAShapeLayer createMaskLayerWithView:view]; view.layer.mask = layer; 圆形进度条效果- 使用CAShapeLayer的strokeStart strokeEnd 属性strokeStart默认值为0，strokeEnd默认值为1。这两个属性都支持动画。 UIView *testView = [[UIView alloc] initWithFrame:CGRectMake(50, 80, 100, 100)]; [self.view addSubview:testView]; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; shapeLayer.frame =testView.bounds; shapeLayer.strokeEnd = 0.7f; shapeLayer.strokeStart = -0.25f; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:testView.bounds]; shapeLayer.path = path.CGPath; shapeLayer.fillColor = [UIColor clearColor].CGColor; shapeLayer.lineWidth = 2.0f; shapeLayer.strokeColor = [UIColor redColor].CGColor; [testView.layer addSublayer:shapeLayer]; // 添加动画 CABasicAnimation *pathAnima = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; pathAnima.duration = 3.0f; // pathAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; pathAnima.fromValue = [NSNumber numberWithFloat:0.0f]; pathAnima.toValue = [NSNumber numberWithFloat:1.0f]; pathAnima.fillMode = kCAFillModeForwards; pathAnima.removedOnCompletion = NO; [shapeLayer addAnimation:pathAnima forKey:@&quot;strokeEndAnimation&quot;]; 提交动画的对号效果 self.testView = [[UIView alloc] initWithFrame:CGRectMake(160, 200, 100, 100)]; [self.view addSubview:self.testView]; UIBezierPath *cornerPath = [UIBezierPath bezierPathWithOvalInRect:self.testView.bounds]; CAShapeLayer *cornerLayer = [CAShapeLayer layer]; cornerLayer.path = cornerPath.CGPath; cornerLayer.fillColor = [UIColor orangeColor].CGColor; [self.testView.layer addSublayer:cornerLayer]; UIBezierPath *bezierPath = [UIBezierPath bezierPath]; [bezierPath moveToPoint:CGPointMake(CGRectGetWidth(self.testView.frame)/4, CGRectGetHeight(self.testView.frame)/2)]; [bezierPath addLineToPoint:CGPointMake(CGRectGetWidth(self.testView.frame)/2, CGRectGetHeight(self.testView.frame)/4*3)]; [bezierPath addLineToPoint:CGPointMake(CGRectGetWidth(self.testView.frame)/4*3, CGRectGetHeight(self.testView.frame)/3)]; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; shapeLayer.lineWidth = 10; shapeLayer.fillColor = [UIColor clearColor].CGColor; shapeLayer.strokeColor = [UIColor greenColor].CGColor; shapeLayer.lineCap = kCALineCapRound; shapeLayer.lineJoin = kCALineJoinRound; shapeLayer.path = bezierPath.CGPath; [self.testView.layer addSublayer:shapeLayer]; // 动画效果 // 使用CAAnimation 如果不做额外的操作，动画会在结束之后回到初始状态 CABasicAnimation *corAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; corAnimation.duration = 0.8f; corAnimation.fromValue = [NSNumber numberWithFloat:0.f]; corAnimation.toValue = [NSNumber numberWithFloat:1.f]; corAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; corAnimation.fillMode = kCAFillModeForwards; corAnimation.removedOnCompletion = NO; [shapeLayer addAnimation:corAnimation forKey:@&quot;strokeEndAnimation&quot;]; 基础动画 平移动画 self.testView = [[UIView alloc] initWithFrame:CGRectMake(150, 200, 80, 80)]; self.testView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:self.testView]; CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)]; anima.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-75)]; anima.duration = 1.0f; //如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。 anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; anima.fillMode = kCAFillModeForwards; anima.removedOnCompletion = NO; [self.testView.layer addAnimation:anima forKey:@&quot;positionAnimation&quot;]; 透明度动画 CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; anima.fromValue = [NSNumber numberWithFloat:1.0f]; anima.toValue = [NSNumber numberWithFloat:0.2f]; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;opacityAniamtion&quot;]; 缩放动画 CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;]; anima.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anima.toValue = [NSNumber numberWithFloat:2.0f]; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale.x&quot;]; anima.toValue = [NSNumber numberWithFloat:0.2f]; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; - 旋转动画 CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; anima.toValue = [NSNumber numberWithFloat:M_PI_2]; anima.duration = 0.3f; anima.repeatCount = MAXFLOAT; //valueWithCATransform3D作用与layer CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;]; anima.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_2, 0, 0, 1)]; anima.duration = 0.3f; anima.repeatCount = MAXFLOAT; [self.testView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;]; // CGAffineTransform作用与View self.testView.transform = CGAffineTransformMakeRotation(0); [UIView animateWithDuration:0.3f animations:^{ self.testView.transform = CGAffineTransformMakeRotation(M_PI_2); }]; 关键帧动画 基本使用 CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT/2+50)]; anima.values = [NSArray arrayWithObjects:value0,value1,value2,nil]; anima.duration = 2.0f; anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]; [self.testView.layer addAnimation:anima forKey:@&quot;keyFrameAnimation&quot;]; path动画 CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 100, 100)]; anima.path = path.CGPath; anima.duration = 2.0f; [self.testView.layer addAnimation:anima forKey:@&quot;pathAnimation&quot;]; 抖动动画 CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; // transform.rotion = transform.rotion.z NSValue *value1 = [NSNumber numberWithFloat:-M_PI/180*2]; NSValue *value2 = [NSNumber numberWithFloat:M_PI/180*2]; NSValue *value3 = [NSNumber numberWithFloat:-M_PI/180*2]; anima.values = @[value1,value2,value3]; anima.repeatCount = MAXFLOAT; [self.testView.layer addAnimation:anima forKey:@&quot;shakeAnimation&quot;]; group组动画 同时执行的组动画 // 位移动画 CAKeyframeAnimation *anima1 = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-50)]; NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2-50)]; NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2+50)]; NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2+50)]; NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2-50)]; NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-50)]; anima1.values = [NSArray arrayWithObjects:value0,value1,value2,value3,value4,value5, nil]; // 缩放动画 CABasicAnimation *anima2 = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anima2.fromValue = [NSNumber numberWithFloat:0.8f]; anima2.toValue = [NSNumber numberWithFloat:2.0f]; // 旋转动画 CABasicAnimation *anima3 = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; anima3.toValue = [NSNumber numberWithFloat:M_PI*4]; //组动画 CAAnimationGroup *groupAnimation = [CAAnimationGroup animation]; groupAnimation.animations = [NSArray arrayWithObjects:anima1,anima2,anima3,nil]; groupAnimation.duration = 4.0f; [self.testView.layer addAnimation:groupAnimation forKey:@&quot;groupAnimation&quot;]; 顺序执行的组动画 CFTimeInterval currentTime = CACurrentMediaTime(); //位移动画 CABasicAnimation *anima1 = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; anima1.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)]; anima1.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/2, SCREEN_HEIGHT/2-75)]; anima1.beginTime = currentTime; anima1.duration = 1.0f; anima1.fillMode = kCAFillModeForwards; anima1.removedOnCompletion = NO; [self.testView.layer addAnimation:anima1 forKey:@&quot;aa&quot;]; //缩放动画 CABasicAnimation *anima2 = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anima2.fromValue = [NSNumber numberWithFloat:0.8f]; anima2.toValue = [NSNumber numberWithFloat:2.0f]; anima2.beginTime = currentTime+1.0f; anima2.duration = 1.0f; anima2.fillMode = kCAFillModeForwards; anima2.removedOnCompletion = NO; [self.testView.layer addAnimation:anima2 forKey:@&quot;bb&quot;]; //旋转动画 CABasicAnimation *anima3 = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; anima3.toValue = [NSNumber numberWithFloat:M_PI*4]; anima3.beginTime = currentTime+2.0f; anima3.duration = 1.0f; anima3.fillMode = kCAFillModeForwards; anima3.removedOnCompletion = NO; [self.testView.layer addAnimation:anima3 forKey:@&quot;cc&quot;]; 过渡动画 淡入淡出动画 CATransition *anima = [CATransition animation]; anima.type = kCATransitionFade; //设置动画的类型 anima.subtype = kCATransitionFromRight; // 设置动画的方向 // anima.startProgress = 0.3; // anima.endProgress = 0.8; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;fadeAnimation&quot;]; 覆盖动画 CATransition *anima = [CATransition animation]; anima.type = kCATransitionMoveIn; anima.subtype = kCATransitionFromRight; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;moveInAnimation&quot;]; push动画 CATransition *anima = [CATransition animation]; anima.type = kCATransitionPush;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;pushAnimation&quot;]; 揭开动画 CATransition *anima = [CATransition animation]; anima.type = kCATransitionReveal; anima.subtype = kCATransitionFromRight; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;revealAnimation&quot;]; 下面是苹果私有API的过渡动画 立方体效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;cube&quot;; anima.subtype = kCATransitionFromRight; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:nil]; 吮吸效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;suckEffect&quot;; anima.subtype = kCATransitionFromRight; anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;suckEffectAnimation&quot;]; 翻转效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;oglFlip&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;oglFlipAnimation&quot;]; 波纹效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;rippleEffect&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;rippleEffectAnimation&quot;]; 翻页效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;pageCurl&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;pageCurlAnimation&quot;]; 反翻页效果 CATransition *anima = [CATransition animation]; anima.type = @&quot;pageUnCurl&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;pageUnCurlAnimation&quot;]; 开镜头动画 CATransition *anima = [CATransition animation]; anima.type = @&quot;cameraIrisHollowOpen&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;cameraIrisHollowOpenAnimation&quot;]; 关镜头动画 CATransition *anima = [CATransition animation]; anima.type = @&quot;cameraIrisHollowClose&quot;;//设置动画的类型 anima.subtype = kCATransitionFromRight; //设置动画的方向 anima.duration = 1.0f; [self.testView.layer addAnimation:anima forKey:@&quot;cameraIrisHollowCloseAnimation&quot;]; 下面是UIView的block动画 // 每次都从初始的位置开始 self.testView.transform = CGAffineTransformIdentity; // [UIView animateWithDuration:1.0f animations:^{ // self.testView.transform = CGAffineTransformMakeTranslation(100, 100); // }]; // 缩放动画 // [UIView animateWithDuration:1.0f animations:^{ // self.testView.transform = CGAffineTransformMakeScale(2, 2); // }]; // 旋转动画 // [UIView animateWithDuration:1.0f animations:^{ // self.testView.transform = CGAffineTransformMakeRotation(M_PI); // }]; // 组合使用 [UIView animateWithDuration:1.0f animations:^{ CGAffineTransform tranForm1 = CGAffineTransformMakeRotation(M_PI); CGAffineTransform tranForm2 = CGAffineTransformScale(tranForm1, 0.5, 0.5); self.testView.transform = CGAffineTransformTranslate(tranForm2, 100, 100); }];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS字典初始化的坑]]></title>
    <url>%2F2018%2F01%2F30%2FNSDictionary%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[iOS 字典初始化的坑 最近在做项目的时候遇到了一种崩溃原因，bugly反馈的崩溃信息是这样的-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[1] JIZHANG + 289980 我们采用的字典初始化方式是字面量的方式，他是iOS 6.0以后新支持的初始化方法 NSDictionary *dictionary =@{@&quot;key1&quot; : value1,@&quot;key2&quot; : value2,@&quot;key3&quot; : value3}; 后来经过测试发现，如果value值为nil时会导致崩溃，崩溃信息和测试代码如下 测试代码 NSString *value = nil; NSDictionary *params = @{@&quot;openid&quot;:value}; 崩溃信息这种字典的初始化方式，要保证不会崩溃，就要对每一个value进行判断，确保不为nil时才插入数据。 还有一种初始化方式是采用标准的初始化方式-以下这种方式当插入value值为nil时，之后的值并不会插入，但是不会崩溃 NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:openid,@&quot;openid&quot;,nickname,@&quot;nickname&quot;,sex,@&quot;sex&quot;,headimgurl,@&quot;headimgurl&quot;,unionid,@&quot;unionid&quot;,nil];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取tabbarvc的bug]]></title>
    <url>%2F2018%2F01%2F11%2FiOS%E8%8E%B7%E5%8F%96tabbarvc%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[iOS 获取tabbar的rootViewController遇到的坑 大家获取tabbarVC通常有两种取法 一种是JZTabBarViewController *tabVC = (JZTabBarViewController *)[UIApplication sharedApplication].keyWindow.rootViewController; 另一种是AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate; JZTabBarViewController *tabVC = (JZTabBarViewController *)appDelegate.window.rootViewController; 之前我们项目中采用的是第一种方式取得，然后调用tabVC.selectedIndex = 0方法，上线之后腾讯bugly反馈了一个崩溃的bug，bug反馈信息为-[UIViewController setSelectedIndex:]: unrecognized selector sent to instance 0x125da5d60,这个方法是没有找到该方法，我猜可能是因为用第一种方法取的viewcontroller可能不是tabbarvc，因为我们在项目中有使用[UIApplication sharedApplication].keyWindow加过自定义的view，我猜可能是这个原因，当把加的自定义的view注释掉之后，以上两个方法都可以确保每次拿到的vc是tabbarvc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS本地通知]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[iOS 本地通知(Local Notification) 通知的注意事项：1、app在前台运行的时候，通知不会展示出来 2、点击通知，默认自动打开推送通知的app3、不管app是否打开，通知都可以正常发出 创建本地通知 创建自定义声音的时候，一定要注意在main bunlde加入声音文件，在项目主路径下Build Phases-copy Bundle Resources下面添加音频文件 //创建本地通知 - (void)fireLocalMessage{ UILocalNotification *localNote = [[UILocalNotification alloc]init]; localNote.timeZone = [NSTimeZone defaultTimeZone]; //本地通知的时间 localNote.fireDate = [NSDate date]; //设置通知间隔为每天 localNote.repeatInterval = NSCalendarUnitDay; // localNote.alertTitle = @&quot;记账时间到了，赶快来记一笔吧&quot;; localNote.alertBody = @&quot;记账时间到了，赶快来记一笔吧&quot;; localNote.hasAction = YES; //音效-苹果本地通知支持的音频格式。 aiff wav caf // localNote.soundName = UILocalNotificationDefaultSoundName; localNote.soundName = @&quot;push.caf&quot;; //接收到通知设置bade localNote.applicationIconBadgeNumber = [UIApplication sharedApplication].applicationIconBadgeNumber+1; //设置额外信息,appdelegate中收到通知,可以根据不同的通知的额外信息确定跳转到不同的界面 NSString *hourString = [self.leftArray objectAtIndex:hour]; NSString *minuteString = [self.rightArray objectAtIndex:minute]; NSString *string = [NSString stringWithFormat:@&quot;每天 %@:%@&quot;,hourString,minuteString]; localNote.userInfo = @{@&quot;name&quot;:string}; // 3.调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:localNote]; } AppDelegate.m文件里面的处理- (void)setLocalNotion:(UIApplication *)application launchOptions:(NSDictionary *)launchOptions{ //打开app时候,消除掉badge [application setApplicationIconBadgeNumber:0]; if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0) { // iOS8以后 本地通知必须注册(获取权限) UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert categories:nil]; [application registerUserNotificationSettings:settings]; } //如果是这个key有值,代表是杀死的程序接收到本地通知跳转 if (launchOptions[UIApplicationLaunchOptionsLocationKey]) { // 根据这种方式查看launchOptions的内容 NSLog(@&quot;跳转到指定页面&quot;); } } - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{ NSLog(@&quot;收到本地通知&quot;); // 可以让用户跳转到指定界面 app在前台接收到通知直接跳转界面不太好,所以要判断一下,是从后台进入前台还是本身就在前台 if (application.applicationState == UIApplicationStateInactive) {// 进入前台时候 NSLog(@&quot;跳转到指定界面&quot;); // 如果接收到不同的通知,跳转到不同的界面: NSLog(@&quot;进行界面的跳转&quot;); NSLog(@&quot;%@&quot;, notification.userInfo); } else{ // NSInteger badgeNumber = 0; // [notification setApplicationIconBadgeNumber:badgeNumber]; } }]]></content>
      <categories>
        <category>iOS,本地通知</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS绘图]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[iOS 绘图 关于下面的绘制图形都是在drawRect方法中，所以我们需要建立一个类叫CustonView，继承于UIView，然后实现drawRect方法。 绘制一个字符串UIFont *helveticacabold = [UIFont fontWithName:@&quot;HelveticaNeue-Bold&quot; size:40.f]; NSString *string = @&quot;some String&quot;; NSDictionary *attibute = @{NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:helveticacabold}; [string drawAtPoint:CGPointMake(40, 200) withAttributes:attibute]; 将字符串画在一个矩形中//画在一个矩形 UIFont *helveticacabold = [UIFont fontWithName:@&quot;HelveticaNeue-Bold&quot; size:40.f]; NSString *string = @&quot;some String&quot;; NSDictionary *attibute = @{NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:helveticacabold}; [string drawInRect:CGRectMake(40, 200, 100, 100) withAttributes:attibute]; 获取color的分量信息UIColor *steelBlueColor = [UIColor colorWithRed:0.3f green:0.4f blue:0.6f alpha:1.0f]; CGColorRef colorRef = steelBlueColor.CGColor; const CGFloat *components = CGColorGetComponents(colorRef); NSUInteger compentsCount = CGColorGetNumberOfComponents(colorRef); NSUInteger count = 0; for (count = 0; count &lt; compentsCount; count++) { NSLog(@&quot;compenent %lu = %.02f&quot;,count+1,components[count]); } 绘制线段// 1. 为图形上下文选择一个颜色 [[UIColor brownColor] set]; // 2. 获取图形上下文的句柄 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // 3. 设置线条的宽度 第一个参数是当前图形上下文 ， 第二个是线条的宽度 CGContextSetLineWidth(currentContext, 10.0f); // 4. 设置线条的起点 CGContextMoveToPoint(currentContext, 50.0f, 10.0f); // 5. 设置终点 // 线 CGContextAddLineToPoint(currentContext, 100.0f, 200.0f); // 矩形 // CGContextAddRect(currentContext, CGRectMake(50, 50, 100, 100)); // 6. 绘制上下文 CGContextStrokePath(currentContext); 绘制一个X// 1. 创建一个可变的句柄 CGMutablePathRef path = CGPathCreateMutable(); // 2. 充满屏幕 CGRect screenBounds = [UIScreen mainScreen].bounds; // 3. 开始top-left CGPathMoveToPoint(path, NULL, screenBounds.origin.x, screenBounds.origin.y); CGPathAddLineToPoint(path, NULL, screenBounds.size.width, screenBounds.size.height); // 4. 开始另一条线，top-right CGPathMoveToPoint(path, NULL, screenBounds.size.width, screenBounds.origin.y); // 5. 画线，form top-right to bottom-left CGPathAddLineToPoint(path, NULL, screenBounds.origin.x, screenBounds.size.height); // 6. 获取图形上下文 CGContextRef currentRef = UIGraphicsGetCurrentContext(); CGContextAddPath(currentRef, path); [[UIColor blueColor] setStroke]; CGContextDrawPath(currentRef, kCGPathStroke); CGPathRelease(path); 绘制矩形CGMutablePathRef path = CGPathCreateMutable(); CGRect rectangle = CGRectMake(10.0f, 10.0f, 200.0f, 300.0f); CGPathAddRect(path, NULL, rectangle); CGContextRef currentContext = UIGraphicsGetCurrentContext(); CGContextAddPath(currentContext, path); //充满矩形的颜色 [[UIColor yellowColor] setFill]; //画线的颜色 [[UIColor brownColor] setStroke]; CGContextSetLineWidth(currentContext, 10.0f); CGContextDrawPath(currentContext, kCGPathFillStroke); CGPathRelease(path); 为形状添加阴影// 1. 获取图形上下文 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // 避免第二个矩形会被应用，需要保存上下文 CGContextSaveGState(currentContext); // 2. 设置阴影 参数： 1.图形上下文 2. 偏移量-偏移量相对于将要应用阴影的形状的右边和底部。x偏移量越大，阴影更向形状的右边延伸，y偏移量越大，阴影更向形状的底部延伸。 3. 应用到阴影的模糊值，· CGContextSetShadowWithColor(currentContext, CGSizeMake(10.0f, 10.0f), 20.0f, [UIColor grayColor].CGColor); CGMutablePathRef path = CGPathCreateMutable(); CGRect firstRect = CGRectMake(55.0f, 60.0f, 150.0f, 150.0f); CGPathAddRect(path, NULL, firstRect); CGContextAddPath(currentContext, path); [[UIColor colorWithRed:0.20f green:0.60f blue:0.80f alpha:1.0f] setFill]; CGContextDrawPath(currentContext, kCGPathFill); CGPathRelease(path); // 回到之前上下文的状态 避免第二个矩形会被应用， CGContextRestoreGState(currentContext); 创建和绘制渐变// 1. 创建色彩空间 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // CGContextSaveGState(currentContext); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); UIColor *startColor = [UIColor orangeColor]; CGFloat *startColorComponents = (CGFloat *)CGColorGetComponents([startColor CGColor]); UIColor *endColor = [UIColor blueColor]; CGFloat *endColorComponents = (CGFloat *)CGColorGetComponents([endColor CGColor]); // 2. 获取开始颜色和终点颜色的分量之后，我们将他们放入一个扁平数组传递到CGGradientCreateWithColorComonents函数 CGFloat colorComponents[8] = { startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3], //终点颜色分量 endColorComponents[0], endColorComponents[1], endColorComponents[2], endColorComponents[3], }; // 3. 因为我们在数组中只有两个颜色，所以我们首先需要指定的是渐变最开始的位置0。0f,接着指定他结束的位置1.0f， CGFloat colorIndices[2] = { 0.0f, /* color 0 */ 1.0f, /* color 1 */ }; // 4. 调用CGGradientCreateWithColorComonents函数 CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, (CGFloat *)colorComponents, (CGFloat*)colorIndices, 2); // 5. 释放色彩空间 CGColorSpaceRelease(colorSpace); // 6. 绘制线性渐变 CGRect screenBounds = [UIScreen mainScreen].bounds; CGPoint startPoint, endPoint; startPoint = CGPointMake(120,260); endPoint = CGPointMake(200.0f,220); // kCGGradientDrawsAfterEndLocation 扩展整个渐变到渐变的终点之后的所有点 kCGGradientDrawsBeforeStartLocation 扩展整个渐变到渐变的起点之前的所有点 // 0 不扩展 CGContextDrawLinearGradient(currentContext, gradient, startPoint, endPoint, 0); CGGradientRelease(gradient);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取当前app的名称和版本号]]></title>
    <url>%2F2017%2F11%2F13%2F%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[#iOS获取当前app的名称和版本号 NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; app名称 NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; app版本 NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; app build版本 NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; 手机序列号 NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; NSLog(@&quot;手机序列号: %@&quot;,identifierNumber); 手机别名： 用户定义的名称 NSString* userPhoneName = [[UIDevice currentDevice] name]; NSLog(@&quot;手机别名: %@&quot;, userPhoneName); 设备名称 NSString* deviceName = [[UIDevice currentDevice] systemName]; NSLog(@&quot;设备名称: %@&quot;,deviceName ); 手机系统版本 NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion); 手机型号 NSString* phoneModel = [[UIDevice currentDevice] model]; NSLog(@&quot;手机型号: %@&quot;,phoneModel ); 地方型号 （国际化区域名称） NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; 当前应用名称 NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; NSLog(@&quot;当前应用名称：%@&quot;,appCurName); 当前应用软件版本 比如：1.0.1 NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion); 当前应用版本号码 int类型 NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum);]]></content>
      <categories>
        <category>杂笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Hexo Next主题添加分享及打赏功能]]></title>
    <url>%2F2017%2F10%2F13%2F%E4%B8%BAHexo-Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E5%8F%8A%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[为Hexo Next主题添加分享及打赏功能博客地址：往事亦如风的博客 要想先看打赏和分享功能效果，请移步我的博客 打赏功能 因为next主题自带打赏功能，所以我们只需要在next的主题配置文件中找到如下代码,image文件夹是我在blog/source下面建立的文件夹，然后把你的微信及支付宝收钱码图片拉进去，修改名字为wechatreward.png和alipayreward.png reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /image/wechatreward.png alipay: /image/alipayreward.png 分享功能要想集成分享功能，先要去ShareSDK注册账号和项目，然后得到项目的appkey 假如你不嫌麻烦，下面是在网页上分享按钮的代码，你可以将以下代码添加到想要显示的位置，添加完之后需要修改代码中的appkey是你之前申请的appkey &lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tencentweibo&quot;&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-renren&quot;&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-kaixin&quot;&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 添加到Next主题中那么怎么添加到next主题上呢。步骤如下 创建文件我们首先要在主题文件夹下的layout文件夹找到_partials下的share文件夹，之后添加一个名为sharesdk.swig的文件。我们可以看出来。这个文件夹下放的全部是分享的配置文件.添加的内容为上面的那一大段代码。只需要修改一部分。修改的部分为： &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey={{ theme.shareSDKappkey }}&quot;&gt;&lt;/script&gt; 修改这写的目的是为了让我们能够在主题的配置文件中添加appkey。（只需要在主题的配置文件中添加一个shareSDKappkey并为其附上值即可）。 添加可选配置虽然我们添加了sharesdk的分享的按钮了，但是如果有一天我们不想使用了呢。当然，很简单。只需要修改配置文件就可以了。那么如何实现呢？首先，找到主题文件夹下的layout文件夹下的post.swig 大概在16行左右添加 &lt;div class=&quot;post-spread&quot;&gt; {% if theme.jiathis %} {% include '_partials/share/jiathis.swig' %} {% elseif theme.baidushare %} {% include '_partials/share/baidushare.swig' %} {% elseif theme.add_this_id %} {% include '_partials/share/add-this.swig' %} {% elseif theme.duoshuo_shortname and theme.duoshuo_share %} {% include '_partials/share/duoshuo_share.swig' %} {% elseif theme.sharesdk %} {% include '_partials/share/sharesdk.swig' %} {% endif %} &lt;/div&gt; 添加了代码 {% elseif theme.sharesdk %} {% include '_partials/share/sharesdk.swig' %} 这段代码就是根据主题文件的配置，来为文档添加相应的swig文件。要想实现在配置文件中选择性的使用分享功能，只需要在配置文件中修改即可。 修改_config.yml接下来就是修改项目的配置文件了。 在主题的配置文件中添加： #Share sharesdk: true shareSDKappkey: appkey 如果想使用就可以设置为true并添加appkey了。当然不想使用。直接注释就可以了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上搭建基于Github的hexo博客]]></title>
    <url>%2F2017%2F10%2F11%2FMac-%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGithub%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Mac 上搭建基于Github的hexo博客博客地址：往事亦如风的博客 hexo官方文档 本来想搭一个自己的博客，但是因为服务器真心买不起，所以就使用gitpages搭建一个免费的博客。 环境配置 Node.js 点击链接进入Node.js官网, 下载v5.5.0 Stable 一路安装即可。 因为Xcode自带git，所以就没必要下了，如果没有安装的同学可以移步hexo官方文档去下载git 安装Hexo 当Node.js和git安装好，下面就需要安装Hexo了，终端执行以下命令 $ sudo npm install -g hexo Hexo 初始化在桌面新建一个blog文件夹，然后cd 到那个目录下执行以下命令 $ hexo init $ npm install $ hexo s 此时在浏览器中打开网址http://localhost:4000相信就可以看到一个静态网页 关联Github创建Github账号并新建项目项目名称为用户名.github.io的固定写法,如下图所示 cd 到blog文件夹下,vim打开_config.yml，命令如下 $ vim _config.yml 打开后滑倒最后，修改成下面的样子,下面的coding是我在codeing上新建的一个项目，因为在github上访问太慢，所以我新建了一个仓库。 deploy: type: git repository: github: https://github.com/jikaipenggithub/jikaipenggithub.github.io coding: https://git.coding.net/a751122452/a751122452.coding.me.git branch: master 注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错. 修改完成之后保存退出，然后输入以下命令 hexo clean hexo g hexo d 当以上命令执行完成之后，在浏览器打开http://你的用户名.github.io，能看到和打开http://localhost:4000一样的页面。 安装主题Hexo官网主题页献给大家大家可以去下载自己喜欢的主题去配置，以下以hexo-theme-next为例终端cd到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： $ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo g //生成缓存和静态文件 $ hexo d //重新部署到服务器 至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 绑定个人域名 Github端 在/blog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：kaipeng.net.cn写入,如果换主题需要在新的主题下面的source下重建CNAME,并写入域名。 域名解析如下图所示，蓝色箭头指的ip是我的github的仓库地址，你在终端ping一下就知道了，另外两个是coding的仓库地址，要是有不懂的滴滴我]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
