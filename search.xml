<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS本地通知]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[iOS 本地通知(Local Notification) 通知的注意事项：1、app在前台运行的时候，通知不会展示出来 2、点击通知，默认自动打开推送通知的app3、不管app是否打开，通知都可以正常发出 创建本地通知 创建自定义声音的时候，一定要注意在main bunlde加入声音文件，在项目主路径下Build Phases-copy Bundle Resources下面添加音频文件 //创建本地通知 - (void)fireLocalMessage{ UILocalNotification *localNote = [[UILocalNotification alloc]init]; localNote.timeZone = [NSTimeZone defaultTimeZone]; //本地通知的时间 localNote.fireDate = [NSDate date]; //设置通知间隔为每天 localNote.repeatInterval = NSCalendarUnitDay; // localNote.alertTitle = @&quot;记账时间到了，赶快来记一笔吧&quot;; localNote.alertBody = @&quot;记账时间到了，赶快来记一笔吧&quot;; localNote.hasAction = YES; //音效-苹果本地通知支持的音频格式。 aiff wav caf // localNote.soundName = UILocalNotificationDefaultSoundName; localNote.soundName = @&quot;push.caf&quot;; //接收到通知设置bade localNote.applicationIconBadgeNumber = [UIApplication sharedApplication].applicationIconBadgeNumber+1; //设置额外信息,appdelegate中收到通知,可以根据不同的通知的额外信息确定跳转到不同的界面 NSString *hourString = [self.leftArray objectAtIndex:hour]; NSString *minuteString = [self.rightArray objectAtIndex:minute]; NSString *string = [NSString stringWithFormat:@&quot;每天 %@:%@&quot;,hourString,minuteString]; localNote.userInfo = @{@&quot;name&quot;:string}; // 3.调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:localNote]; } AppDelegate.m文件里面的处理- (void)setLocalNotion:(UIApplication *)application launchOptions:(NSDictionary *)launchOptions{ //打开app时候,消除掉badge [application setApplicationIconBadgeNumber:0]; if ([[UIDevice currentDevice].systemVersion doubleValue] &gt;= 8.0) { // iOS8以后 本地通知必须注册(获取权限) UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert categories:nil]; [application registerUserNotificationSettings:settings]; } //如果是这个key有值,代表是杀死的程序接收到本地通知跳转 if (launchOptions[UIApplicationLaunchOptionsLocationKey]) { // 根据这种方式查看launchOptions的内容 NSLog(@&quot;跳转到指定页面&quot;); } } - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{ NSLog(@&quot;收到本地通知&quot;); // 可以让用户跳转到指定界面 app在前台接收到通知直接跳转界面不太好,所以要判断一下,是从后台进入前台还是本身就在前台 if (application.applicationState == UIApplicationStateInactive) {// 进入前台时候 NSLog(@&quot;跳转到指定界面&quot;); // 如果接收到不同的通知,跳转到不同的界面: NSLog(@&quot;进行界面的跳转&quot;); NSLog(@&quot;%@&quot;, notification.userInfo); } else{ // NSInteger badgeNumber = 0; // [notification setApplicationIconBadgeNumber:badgeNumber]; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取tabbarvc的bug]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E8%8E%B7%E5%8F%96tabbarvc%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[iOS 获取tabbar的rootViewController遇到的坑 大家获取tabbarVC通常有两种取法 一种是JZTabBarViewController *tabVC = (JZTabBarViewController *)[UIApplication sharedApplication].keyWindow.rootViewController; 另一种是AppDelegate *appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate; JZTabBarViewController *tabVC = (JZTabBarViewController *)appDelegate.window.rootViewController; 之前我们项目中采用的是第一种方式取得，然后调用tabVC.selectedIndex = 0方法，上线之后腾讯bugly反馈了一个崩溃的bug，bug反馈信息为-[UIViewController setSelectedIndex:]: unrecognized selector sent to instance 0x125da5d60,这个方法是没有找到该方法，我猜可能是因为用第一种方法取的viewcontroller可能不是tabbarvc，因为我们在项目中有使用[UIApplication sharedApplication].keyWindow加过自定义的view，我猜可能是这个原因，当把加的自定义的view注释掉之后，以上两个方法都可以确保每次拿到的vc是tabbarvc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS绘图]]></title>
    <url>%2F2017%2F11%2F30%2FiOS%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[iOS 绘图 关于下面的绘制图形都是在drawRect方法中，所以我们需要建立一个类叫CustonView，继承于UIView，然后实现drawRect方法。 绘制一个字符串UIFont *helveticacabold = [UIFont fontWithName:@&quot;HelveticaNeue-Bold&quot; size:40.f]; NSString *string = @&quot;some String&quot;; NSDictionary *attibute = @{NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:helveticacabold}; [string drawAtPoint:CGPointMake(40, 200) withAttributes:attibute]; 将字符串画在一个矩形中//画在一个矩形 UIFont *helveticacabold = [UIFont fontWithName:@&quot;HelveticaNeue-Bold&quot; size:40.f]; NSString *string = @&quot;some String&quot;; NSDictionary *attibute = @{NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:helveticacabold}; [string drawInRect:CGRectMake(40, 200, 100, 100) withAttributes:attibute]; 获取color的分量信息UIColor *steelBlueColor = [UIColor colorWithRed:0.3f green:0.4f blue:0.6f alpha:1.0f]; CGColorRef colorRef = steelBlueColor.CGColor; const CGFloat *components = CGColorGetComponents(colorRef); NSUInteger compentsCount = CGColorGetNumberOfComponents(colorRef); NSUInteger count = 0; for (count = 0; count &lt; compentsCount; count++) { NSLog(@&quot;compenent %lu = %.02f&quot;,count+1,components[count]); } 绘制线段// 1. 为图形上下文选择一个颜色 [[UIColor brownColor] set]; // 2. 获取图形上下文的句柄 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // 3. 设置线条的宽度 第一个参数是当前图形上下文 ， 第二个是线条的宽度 CGContextSetLineWidth(currentContext, 10.0f); // 4. 设置线条的起点 CGContextMoveToPoint(currentContext, 50.0f, 10.0f); // 5. 设置终点 // 线 CGContextAddLineToPoint(currentContext, 100.0f, 200.0f); // 矩形 // CGContextAddRect(currentContext, CGRectMake(50, 50, 100, 100)); // 6. 绘制上下文 CGContextStrokePath(currentContext); 绘制一个X// 1. 创建一个可变的句柄 CGMutablePathRef path = CGPathCreateMutable(); // 2. 充满屏幕 CGRect screenBounds = [UIScreen mainScreen].bounds; // 3. 开始top-left CGPathMoveToPoint(path, NULL, screenBounds.origin.x, screenBounds.origin.y); CGPathAddLineToPoint(path, NULL, screenBounds.size.width, screenBounds.size.height); // 4. 开始另一条线，top-right CGPathMoveToPoint(path, NULL, screenBounds.size.width, screenBounds.origin.y); // 5. 画线，form top-right to bottom-left CGPathAddLineToPoint(path, NULL, screenBounds.origin.x, screenBounds.size.height); // 6. 获取图形上下文 CGContextRef currentRef = UIGraphicsGetCurrentContext(); CGContextAddPath(currentRef, path); [[UIColor blueColor] setStroke]; CGContextDrawPath(currentRef, kCGPathStroke); CGPathRelease(path); 绘制矩形CGMutablePathRef path = CGPathCreateMutable(); CGRect rectangle = CGRectMake(10.0f, 10.0f, 200.0f, 300.0f); CGPathAddRect(path, NULL, rectangle); CGContextRef currentContext = UIGraphicsGetCurrentContext(); CGContextAddPath(currentContext, path); //充满矩形的颜色 [[UIColor yellowColor] setFill]; //画线的颜色 [[UIColor brownColor] setStroke]; CGContextSetLineWidth(currentContext, 10.0f); CGContextDrawPath(currentContext, kCGPathFillStroke); CGPathRelease(path); 为形状添加阴影// 1. 获取图形上下文 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // 避免第二个矩形会被应用，需要保存上下文 CGContextSaveGState(currentContext); // 2. 设置阴影 参数： 1.图形上下文 2. 偏移量-偏移量相对于将要应用阴影的形状的右边和底部。x偏移量越大，阴影更向形状的右边延伸，y偏移量越大，阴影更向形状的底部延伸。 3. 应用到阴影的模糊值，· CGContextSetShadowWithColor(currentContext, CGSizeMake(10.0f, 10.0f), 20.0f, [UIColor grayColor].CGColor); CGMutablePathRef path = CGPathCreateMutable(); CGRect firstRect = CGRectMake(55.0f, 60.0f, 150.0f, 150.0f); CGPathAddRect(path, NULL, firstRect); CGContextAddPath(currentContext, path); [[UIColor colorWithRed:0.20f green:0.60f blue:0.80f alpha:1.0f] setFill]; CGContextDrawPath(currentContext, kCGPathFill); CGPathRelease(path); // 回到之前上下文的状态 避免第二个矩形会被应用， CGContextRestoreGState(currentContext); 创建和绘制渐变// 1. 创建色彩空间 CGContextRef currentContext = UIGraphicsGetCurrentContext(); // CGContextSaveGState(currentContext); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); UIColor *startColor = [UIColor orangeColor]; CGFloat *startColorComponents = (CGFloat *)CGColorGetComponents([startColor CGColor]); UIColor *endColor = [UIColor blueColor]; CGFloat *endColorComponents = (CGFloat *)CGColorGetComponents([endColor CGColor]); // 2. 获取开始颜色和终点颜色的分量之后，我们将他们放入一个扁平数组传递到CGGradientCreateWithColorComonents函数 CGFloat colorComponents[8] = { startColorComponents[0], startColorComponents[1], startColorComponents[2], startColorComponents[3], //终点颜色分量 endColorComponents[0], endColorComponents[1], endColorComponents[2], endColorComponents[3], }; // 3. 因为我们在数组中只有两个颜色，所以我们首先需要指定的是渐变最开始的位置0。0f,接着指定他结束的位置1.0f， CGFloat colorIndices[2] = { 0.0f, /* color 0 */ 1.0f, /* color 1 */ }; // 4. 调用CGGradientCreateWithColorComonents函数 CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, (CGFloat *)colorComponents, (CGFloat*)colorIndices, 2); // 5. 释放色彩空间 CGColorSpaceRelease(colorSpace); // 6. 绘制线性渐变 CGRect screenBounds = [UIScreen mainScreen].bounds; CGPoint startPoint, endPoint; startPoint = CGPointMake(120,260); endPoint = CGPointMake(200.0f,220); // kCGGradientDrawsAfterEndLocation 扩展整个渐变到渐变的终点之后的所有点 kCGGradientDrawsBeforeStartLocation 扩展整个渐变到渐变的起点之前的所有点 // 0 不扩展 CGContextDrawLinearGradient(currentContext, gradient, startPoint, endPoint, 0); CGGradientRelease(gradient);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取当前app的名称和版本号]]></title>
    <url>%2F2017%2F11%2F13%2F%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[#iOS获取当前app的名称和版本号 NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; app名称 NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; app版本 NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; app build版本 NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; 手机序列号 NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; NSLog(@&quot;手机序列号: %@&quot;,identifierNumber); 手机别名： 用户定义的名称 NSString* userPhoneName = [[UIDevice currentDevice] name]; NSLog(@&quot;手机别名: %@&quot;, userPhoneName); 设备名称 NSString* deviceName = [[UIDevice currentDevice] systemName]; NSLog(@&quot;设备名称: %@&quot;,deviceName ); 手机系统版本 NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion); 手机型号 NSString* phoneModel = [[UIDevice currentDevice] model]; NSLog(@&quot;手机型号: %@&quot;,phoneModel ); 地方型号 （国际化区域名称） NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; 当前应用名称 NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; NSLog(@&quot;当前应用名称：%@&quot;,appCurName); 当前应用软件版本 比如：1.0.1 NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion); 当前应用版本号码 int类型 NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum);]]></content>
      <categories>
        <category>杂笔</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Hexo Next主题添加分享及打赏功能]]></title>
    <url>%2F2017%2F10%2F13%2F%E4%B8%BAHexo-Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%E5%8F%8A%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[为Hexo Next主题添加分享及打赏功能博客地址：往事亦如风的博客 要想先看打赏和分享功能效果，请移步我的博客 打赏功能 因为next主题自带打赏功能，所以我们只需要在next的主题配置文件中找到如下代码,image文件夹是我在blog/source下面建立的文件夹，然后把你的微信及支付宝收钱码图片拉进去，修改名字为wechatreward.png和alipayreward.png reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！ wechatpay: /image/wechatreward.png alipay: /image/alipayreward.png 分享功能要想集成分享功能，先要去ShareSDK注册账号和项目，然后得到项目的appkey 假如你不嫌麻烦，下面是在网页上分享按钮的代码，你可以将以下代码添加到想要显示的位置，添加完之后需要修改代码中的appkey是你之前申请的appkey &lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tencentweibo&quot;&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-renren&quot;&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-kaixin&quot;&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 添加到Next主题中那么怎么添加到next主题上呢。步骤如下 创建文件我们首先要在主题文件夹下的layout文件夹找到_partials下的share文件夹，之后添加一个名为sharesdk.swig的文件。我们可以看出来。这个文件夹下放的全部是分享的配置文件.添加的内容为上面的那一大段代码。只需要修改一部分。修改的部分为： &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey={{ theme.shareSDKappkey }}&quot;&gt;&lt;/script&gt; 修改这写的目的是为了让我们能够在主题的配置文件中添加appkey。（只需要在主题的配置文件中添加一个shareSDKappkey并为其附上值即可）。 添加可选配置虽然我们添加了sharesdk的分享的按钮了，但是如果有一天我们不想使用了呢。当然，很简单。只需要修改配置文件就可以了。那么如何实现呢？首先，找到主题文件夹下的layout文件夹下的post.swig 大概在16行左右添加 &lt;div class=&quot;post-spread&quot;&gt; {% if theme.jiathis %} {% include '_partials/share/jiathis.swig' %} {% elseif theme.baidushare %} {% include '_partials/share/baidushare.swig' %} {% elseif theme.add_this_id %} {% include '_partials/share/add-this.swig' %} {% elseif theme.duoshuo_shortname and theme.duoshuo_share %} {% include '_partials/share/duoshuo_share.swig' %} {% elseif theme.sharesdk %} {% include '_partials/share/sharesdk.swig' %} {% endif %} &lt;/div&gt; 添加了代码 {% elseif theme.sharesdk %} {% include '_partials/share/sharesdk.swig' %} 这段代码就是根据主题文件的配置，来为文档添加相应的swig文件。要想实现在配置文件中选择性的使用分享功能，只需要在配置文件中修改即可。 修改_config.yml接下来就是修改项目的配置文件了。 在主题的配置文件中添加： #Share sharesdk: true shareSDKappkey: appkey 如果想使用就可以设置为true并添加appkey了。当然不想使用。直接注释就可以了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 上搭建基于Github的hexo博客]]></title>
    <url>%2F2017%2F10%2F11%2FMac-%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGithub%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Mac 上搭建基于Github的hexo博客博客地址：往事亦如风的博客 hexo官方文档 本来想搭一个自己的博客，但是因为服务器真心买不起，所以就使用gitpages搭建一个免费的博客。 环境配置 Node.js 点击链接进入Node.js官网, 下载v5.5.0 Stable 一路安装即可。 因为Xcode自带git，所以就没必要下了，如果没有安装的同学可以移步hexo官方文档去下载git 安装Hexo 当Node.js和git安装好，下面就需要安装Hexo了，终端执行以下命令 $ sudo npm install -g hexo Hexo 初始化在桌面新建一个blog文件夹，然后cd 到那个目录下执行以下命令 $ hexo init $ npm install $ hexo s 此时在浏览器中打开网址http://localhost:4000相信就可以看到一个静态网页 关联Github创建Github账号并新建项目项目名称为用户名.github.io的固定写法,如下图所示 cd 到blog文件夹下,vim打开_config.yml，命令如下 $ vim _config.yml 打开后滑倒最后，修改成下面的样子,下面的coding是我在codeing上新建的一个项目，因为在github上访问太慢，所以我新建了一个仓库。 deploy: type: git repository: github: https://github.com/jikaipenggithub/jikaipenggithub.github.io coding: https://git.coding.net/a751122452/a751122452.coding.me.git branch: master 注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错. 修改完成之后保存退出，然后输入以下命令 hexo clean hexo g hexo d 当以上命令执行完成之后，在浏览器打开http://你的用户名.github.io，能看到和打开http://localhost:4000一样的页面。 安装主题Hexo官网主题页献给大家大家可以去下载自己喜欢的主题去配置，以下以hexo-theme-next为例终端cd到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： $ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo g //生成缓存和静态文件 $ hexo d //重新部署到服务器 至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 绑定个人域名 Github端 在/blog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：kaipeng.net.cn写入,如果换主题需要在新的主题下面的source下重建CNAME,并写入域名。 域名解析如下图所示，蓝色箭头指的ip是我的github的仓库地址，你在终端ping一下就知道了，另外两个是coding的仓库地址，要是有不懂的滴滴我]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
